---
description: å®‰å…¨è§„èŒƒå’Œæœ€ä½³å®è·µï¼Œç¡®ä¿ç»„ä»¶åº“çš„å®‰å…¨æ€§å’Œæ•°æ®ä¿æŠ¤
globs:
  - 'src/**/*.rs'
  - 'examples/**/*.rs'
  - 'build.rs'
alwaysApply: true
priority: high
---

# å®‰å…¨è§„èŒƒ

## ç›®æ ‡
å»ºç«‹å…¨é¢çš„å®‰å…¨é˜²æŠ¤ä½“ç³»ï¼Œç¡®ä¿ç»„ä»¶åº“åœ¨å„ç§ç¯å¢ƒä¸‹çš„å®‰å…¨æ€§ï¼Œé˜²èŒƒå¸¸è§çš„å®‰å…¨æ¼æ´å’Œæ”»å‡»ã€‚

## ä¸Šä¸‹æ–‡
- åŸºäº Rust çš„å†…å­˜å®‰å…¨ç‰¹æ€§
- é€‚é… WebAssembly è¿è¡Œç¯å¢ƒ
- æ”¯æŒæœåŠ¡ç«¯æ¸²æŸ“ (SSR) å®‰å…¨
- éµå¾ª OWASP å®‰å…¨æŒ‡å—
- ç¬¦åˆç°ä»£ Web å®‰å…¨æ ‡å‡†

## è§„åˆ™

### è¾“å…¥éªŒè¯å’Œæ¸…ç†
- æ‰€æœ‰ç”¨æˆ·è¾“å…¥å¿…é¡»è¿›è¡ŒéªŒè¯å’Œæ¸…ç†
- é˜²æ­¢ XSS (è·¨ç«™è„šæœ¬æ”»å‡»)
- é˜²æ­¢æ³¨å…¥æ”»å‡»
- éªŒè¯æ•°æ®ç±»å‹å’Œæ ¼å¼

âœ… **å®‰å…¨çš„è¾“å…¥å¤„ç†**:
```rust
use html_escape::encode_text;
use regex::Regex;

/// å®‰å…¨çš„æ–‡æœ¬è¾“å…¥ç»„ä»¶
#[component]
pub fn SafeTextInput(props: SafeTextInputProps) -> Element {
    let value = use_signal(|| props.initial_value.unwrap_or_default());

    let sanitized_value = use_memo(move || {
        let raw_value = value();

        // 1. é•¿åº¦é™åˆ¶
        if raw_value.len() > props.max_length.unwrap_or(1000) {
            return Err("Input too long".to_string());
        }

        // 2. å­—ç¬¦è¿‡æ»¤
        let allowed_chars = Regex::new(r"^[a-zA-Z0-9\s\-_.,!?]*$").unwrap();
        if !allowed_chars.is_match(&raw_value) {
            return Err("Invalid characters detected".to_string());
        }

        // 3. HTML è½¬ä¹‰
        let escaped = encode_text(&raw_value);

        // 4. å±é™©æ¨¡å¼æ£€æµ‹
        let dangerous_patterns = [
            r"<script",
            r"javascript:",
            r"data:text/html",
            r"vbscript:",
            r"onload=",
            r"onerror=",
        ];

        for pattern in &dangerous_patterns {
            if raw_value.to_lowercase().contains(pattern) {
                return Err("Potentially dangerous content detected".to_string());
            }
        }

        Ok(escaped.to_string())
    });

    rsx! {
        div {
            class: "ant-input-wrapper",

            input {
                class: "ant-input",
                r#type: "text",
                value: value(),
                maxlength: props.max_length.unwrap_or(1000),
                oninput: move |evt| {
                    value.set(evt.value());
                },
                "data-testid": "safe-text-input"
            }

            if let Err(error) = sanitized_value() {
                div {
                    class: "ant-input-error",
                    "aria-live": "polite",
                    role: "alert",
                    {error}
                }
            }
        }
    }
}
```

âŒ **é¿å…çš„ä¸å®‰å…¨åšæ³•**:
```rust
// ä¸è¦ç›´æ¥æ¸²æŸ“æœªè½¬ä¹‰çš„ç”¨æˆ·è¾“å…¥
rsx! {
    div {
        dangerous_inner_html: user_input, // âŒ å±é™©ï¼
    }
}

// ä¸è¦åœ¨ URL ä¸­ç›´æ¥ä½¿ç”¨ç”¨æˆ·è¾“å…¥
rsx! {
    a {
        href: format!("https://example.com/{}", user_input), // âŒ å¯èƒ½å¯¼è‡´å¼€æ”¾é‡å®šå‘
        "Link"
    }
}
```

### å†…å®¹å®‰å…¨ç­–ç•¥ (CSP)
- å®æ–½ä¸¥æ ¼çš„ CSP å¤´
- é˜²æ­¢å†…è”è„šæœ¬æ‰§è¡Œ
- é™åˆ¶èµ„æºåŠ è½½æ¥æº

âœ… **CSP é…ç½®ç¤ºä¾‹**:
```rust
// src/security/csp.rs
pub struct ContentSecurityPolicy {
    pub directives: Vec<CspDirective>,
}

pub enum CspDirective {
    DefaultSrc(Vec<String>),
    ScriptSrc(Vec<String>),
    StyleSrc(Vec<String>),
    ImgSrc(Vec<String>),
    ConnectSrc(Vec<String>),
    FontSrc(Vec<String>),
    ObjectSrc(Vec<String>),
    MediaSrc(Vec<String>),
    FrameSrc(Vec<String>),
}

impl ContentSecurityPolicy {
    pub fn strict() -> Self {
        Self {
            directives: vec![
                CspDirective::DefaultSrc(vec!["'self'".to_string()]),
                CspDirective::ScriptSrc(vec![
                    "'self'".to_string(),
                    "'unsafe-inline'".to_string(), // ä»…åœ¨å¿…è¦æ—¶ä½¿ç”¨
                ]),
                CspDirective::StyleSrc(vec![
                    "'self'".to_string(),
                    "'unsafe-inline'".to_string(), // CSS-in-JS éœ€è¦
                ]),
                CspDirective::ImgSrc(vec![
                    "'self'".to_string(),
                    "data:".to_string(),
                    "https:".to_string(),
                ]),
                CspDirective::ConnectSrc(vec!["'self'".to_string()]),
                CspDirective::FontSrc(vec![
                    "'self'".to_string(),
                    "data:".to_string(),
                ]),
                CspDirective::ObjectSrc(vec!["'none'".to_string()]),
                CspDirective::MediaSrc(vec!["'self'".to_string()]),
                CspDirective::FrameSrc(vec!["'none'".to_string()]),
            ],
        }
    }

    pub fn to_header_value(&self) -> String {
        self.directives
            .iter()
            .map(|directive| directive.to_string())
            .collect::<Vec<_>>()
            .join("; ")
    }
}
```

### æ•æ„Ÿæ•°æ®å¤„ç†
- é¿å…åœ¨å®¢æˆ·ç«¯å­˜å‚¨æ•æ„Ÿä¿¡æ¯
- å®æ–½æ•°æ®è„±æ•
- å®‰å…¨çš„å¯†é’¥ç®¡ç†

âœ… **å®‰å…¨çš„æ•°æ®å¤„ç†**:
```rust
use zeroize::{Zeroize, ZeroizeOnDrop};
use serde::{Deserialize, Serialize};

/// æ•æ„Ÿå­—ç¬¦ä¸²ç±»å‹ï¼Œè‡ªåŠ¨æ¸…é›¶
#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct SensitiveString(String);

impl SensitiveString {
    pub fn new(value: String) -> Self {
        Self(value)
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// è„±æ•æ˜¾ç¤º
    pub fn masked(&self) -> String {
        if self.0.len() <= 4 {
            "****".to_string()
        } else {
            format!("{}****{}", &self.0[..2], &self.0[self.0.len()-2..])
        }
    }
}

/// å®‰å…¨çš„å¯†ç è¾“å…¥ç»„ä»¶
#[component]
pub fn SecurePasswordInput(props: SecurePasswordInputProps) -> Element {
    let password = use_signal(|| SensitiveString::new(String::new()));
    let show_password = use_signal(|| false);
    let strength = use_signal(|| PasswordStrength::Weak);

    // å¯†ç å¼ºåº¦æ£€æŸ¥
    let check_strength = use_callback(move |pwd: &str| {
        let mut score = 0;

        if pwd.len() >= 8 { score += 1; }
        if pwd.chars().any(|c| c.is_uppercase()) { score += 1; }
        if pwd.chars().any(|c| c.is_lowercase()) { score += 1; }
        if pwd.chars().any(|c| c.is_numeric()) { score += 1; }
        if pwd.chars().any(|c| !c.is_alphanumeric()) { score += 1; }

        match score {
            0..=2 => PasswordStrength::Weak,
            3..=4 => PasswordStrength::Medium,
            5 => PasswordStrength::Strong,
            _ => PasswordStrength::Weak,
        }
    });

    rsx! {
        div {
            class: "ant-password-input",

            div {
                class: "ant-input-group",

                input {
                    class: "ant-input",
                    r#type: if show_password() { "text" } else { "password" },
                    autocomplete: "new-password",
                    spellcheck: false,
                    oninput: move |evt| {
                        let new_password = SensitiveString::new(evt.value());
                        strength.set(check_strength(new_password.as_str()));
                        password.set(new_password);
                    },
                    "data-testid": "password-input"
                }

                button {
                    class: "ant-input-suffix",
                    r#type: "button",
                    onclick: move |_| show_password.set(!show_password()),
                    "aria-label": if show_password() { "Hide password" } else { "Show password" },

                    if show_password() {
                        "ğŸ™ˆ"
                    } else {
                        "ğŸ‘ï¸"
                    }
                }
            }

            // å¯†ç å¼ºåº¦æŒ‡ç¤ºå™¨
            div {
                class: format!("ant-password-strength ant-password-strength-{}",
                              strength().to_string().to_lowercase()),
                "aria-live": "polite",

                match strength() {
                    PasswordStrength::Weak => "Weak password",
                    PasswordStrength::Medium => "Medium password",
                    PasswordStrength::Strong => "Strong password",
                }
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq)]
enum PasswordStrength {
    Weak,
    Medium,
    Strong,
}

impl ToString for PasswordStrength {
    fn to_string(&self) -> String {
        match self {
            Self::Weak => "weak".to_string(),
            Self::Medium => "medium".to_string(),
            Self::Strong => "strong".to_string(),
        }
    }
}
```

### è®¿é—®æ§åˆ¶å’Œæƒé™
- å®æ–½åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ (RBAC)
- æœ€å°æƒé™åŸåˆ™
- å®‰å…¨çš„ä¼šè¯ç®¡ç†

âœ… **æƒé™æ§åˆ¶ç¤ºä¾‹**:
```rust
/// æƒé™æ£€æŸ¥ç»„ä»¶
#[component]
pub fn ProtectedComponent(props: ProtectedComponentProps) -> Element {
    let auth_context = use_context::<AuthContext>();

    // æƒé™éªŒè¯
    let has_permission = use_memo(move || {
        if let Some(user) = auth_context.current_user() {
            props.required_permissions.iter().all(|perm| {
                user.has_permission(perm)
            })
        } else {
            false
        }
    });

    if has_permission() {
        rsx! {
            {props.children}
        }
    } else {
        rsx! {
            div {
                class: "ant-access-denied",
                role: "alert",
                "aria-live": "polite",

                h3 { "Access Denied" }
                p { "You don't have permission to view this content." }

                if auth_context.current_user().is_none() {
                    Button {
                        onclick: move |_| {
                            // é‡å®šå‘åˆ°ç™»å½•é¡µé¢
                            auth_context.redirect_to_login();
                        },
                        "Login"
                    }
                }
            }
        }
    }
}

/// å®‰å…¨çš„è·¯ç”±ä¿æŠ¤
#[component]
pub fn SecureRoute(props: SecureRouteProps) -> Element {
    let auth_context = use_context::<AuthContext>();
    let location = use_location();

    // æ£€æŸ¥è®¤è¯çŠ¶æ€
    let is_authenticated = use_memo(move || {
        auth_context.current_user().is_some()
    });

    // æ£€æŸ¥ä¼šè¯æœ‰æ•ˆæ€§
    let is_session_valid = use_memo(move || {
        if let Some(user) = auth_context.current_user() {
            user.session_expires_at > chrono::Utc::now()
        } else {
            false
        }
    });

    if !is_authenticated() || !is_session_valid() {
        // ä¿å­˜å½“å‰è·¯å¾„ç”¨äºç™»å½•åé‡å®šå‘
        auth_context.set_redirect_path(location.pathname());
        auth_context.redirect_to_login();

        rsx! {
            div {
                class: "ant-loading",
                "Redirecting to login..."
            }
        }
    } else {
        rsx! {
            {props.children}
        }
    }
}
```

### å®‰å…¨çš„ HTTP é€šä¿¡
- å¼ºåˆ¶ä½¿ç”¨ HTTPS
- å®æ–½ CSRF ä¿æŠ¤
- å®‰å…¨çš„ Cookie è®¾ç½®

âœ… **å®‰å…¨çš„ API å®¢æˆ·ç«¯**:
```rust
use reqwest::{Client, header};
use serde::{Deserialize, Serialize};

pub struct SecureApiClient {
    client: Client,
    base_url: String,
    csrf_token: Option<String>,
}

impl SecureApiClient {
    pub fn new(base_url: String) -> Result<Self, Box<dyn std::error::Error>> {
        // ç¡®ä¿ä½¿ç”¨ HTTPS
        if !base_url.starts_with("https://") && !base_url.starts_with("http://localhost") {
            return Err("Only HTTPS URLs are allowed in production".into());
        }

        let mut headers = header::HeaderMap::new();
        headers.insert(
            header::USER_AGENT,
            header::HeaderValue::from_static("AntDesignDioxus/1.0")
        );
        headers.insert(
            header::ACCEPT,
            header::HeaderValue::from_static("application/json")
        );

        let client = Client::builder()
            .default_headers(headers)
            .timeout(std::time::Duration::from_secs(30))
            .redirect(reqwest::redirect::Policy::limited(3))
            .build()?;

        Ok(Self {
            client,
            base_url,
            csrf_token: None,
        })
    }

    pub async fn get_csrf_token(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let response = self.client
            .get(&format!("{}/api/csrf-token", self.base_url))
            .send()
            .await?;

        if response.status().is_success() {
            let token: CsrfTokenResponse = response.json().await?;
            self.csrf_token = Some(token.token);
        }

        Ok(())
    }

    pub async fn post<T, R>(&self, endpoint: &str, data: &T) -> Result<R, Box<dyn std::error::Error>>
    where
        T: Serialize,
        R: for<'de> Deserialize<'de>,
    {
        let mut request = self.client
            .post(&format!("{}{}", self.base_url, endpoint))
            .json(data);

        // æ·»åŠ  CSRF ä»¤ç‰Œ
        if let Some(ref token) = self.csrf_token {
            request = request.header("X-CSRF-Token", token);
        }

        let response = request.send().await?;

        if response.status().is_success() {
            Ok(response.json().await?)
        } else {
            Err(format!("API request failed: {}", response.status()).into())
        }
    }
}

#[derive(Deserialize)]
struct CsrfTokenResponse {
    token: String,
}
```

### é”™è¯¯å¤„ç†å’Œæ—¥å¿—å®‰å…¨
- é¿å…æ³„éœ²æ•æ„Ÿä¿¡æ¯
- å®‰å…¨çš„é”™è¯¯æ¶ˆæ¯
- å®¡è®¡æ—¥å¿—è®°å½•

âœ… **å®‰å…¨çš„é”™è¯¯å¤„ç†**:
```rust
/// å®‰å…¨çš„é”™è¯¯ç±»å‹
#[derive(Debug, Clone)]
pub enum SecureError {
    /// ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
    UserFriendly(String),
    /// ç³»ç»Ÿå†…éƒ¨é”™è¯¯ï¼ˆä¸æš´éœ²ç»™ç”¨æˆ·ï¼‰
    Internal {
        message: String,
        error_id: String,
    },
    /// éªŒè¯é”™è¯¯
    Validation(Vec<ValidationError>),
}

impl SecureError {
    /// è·å–ç”¨æˆ·å®‰å…¨çš„é”™è¯¯æ¶ˆæ¯
    pub fn user_message(&self) -> String {
        match self {
            Self::UserFriendly(msg) => msg.clone(),
            Self::Internal { error_id, .. } => {
                format!("An internal error occurred. Error ID: {}", error_id)
            },
            Self::Validation(errors) => {
                errors.iter()
                    .map(|e| e.message.clone())
                    .collect::<Vec<_>>()
                    .join(", ")
            },
        }
    }

    /// è®°å½•é”™è¯¯åˆ°å®‰å…¨æ—¥å¿—
    pub fn log_securely(&self) {
        match self {
            Self::Internal { message, error_id } => {
                // è®°å½•å®Œæ•´é”™è¯¯ä¿¡æ¯åˆ°å®‰å…¨æ—¥å¿—
                log::error!("Internal error [{}]: {}", error_id, message);
            },
            Self::UserFriendly(msg) => {
                log::info!("User error: {}", msg);
            },
            Self::Validation(errors) => {
                log::info!("Validation errors: {:?}", errors);
            },
        }
    }
}

/// å®‰å…¨çš„é”™è¯¯è¾¹ç•Œç»„ä»¶
#[component]
pub fn SecureErrorBoundary(props: SecureErrorBoundaryProps) -> Element {
    let error_state = use_signal(|| None::<SecureError>);

    // é”™è¯¯æ¢å¤å¤„ç†
    let handle_error = use_callback(move |error: SecureError| {
        // è®°å½•é”™è¯¯
        error.log_securely();

        // è®¾ç½®ç”¨æˆ·å‹å¥½çš„é”™è¯¯çŠ¶æ€
        error_state.set(Some(error));
    });

    if let Some(error) = error_state() {
        rsx! {
            div {
                class: "ant-error-boundary",
                role: "alert",
                "aria-live": "polite",

                div {
                    class: "ant-error-content",

                    h3 {
                        class: "ant-error-title",
                        "Something went wrong"
                    }

                    p {
                        class: "ant-error-message",
                        {error.user_message()}
                    }

                    div {
                        class: "ant-error-actions",

                        Button {
                            onclick: move |_| {
                                error_state.set(None);
                            },
                            "Try Again"
                        }

                        Button {
                            button_type: ButtonType::Link,
                            onclick: move |_| {
                                // é‡å®šå‘åˆ°é¦–é¡µæˆ–å®‰å…¨é¡µé¢
                                web_sys::window()
                                    .unwrap()
                                    .location()
                                    .set_href("/")
                                    .unwrap();
                            },
                            "Go Home"
                        }
                    }
                }
            }
        }
    } else {
        rsx! {
            {props.children}
        }
    }
}
```

### ä¾èµ–å®‰å…¨ç®¡ç†
- å®šæœŸæ›´æ–°ä¾èµ–
- å®‰å…¨æ¼æ´æ‰«æ
- æœ€å°åŒ–ä¾èµ–æ•°é‡

âœ… **å®‰å…¨çš„ä¾èµ–ç®¡ç†**:
```toml
# Cargo.toml - å®‰å…¨é…ç½®
[dependencies]
# ä½¿ç”¨å…·ä½“ç‰ˆæœ¬å·ï¼Œé¿å…è‡ªåŠ¨æ›´æ–°
dioxus = "=0.6.3"
dioxus-web = "=0.6.3"

# å®‰å…¨ç›¸å…³ä¾èµ–
html-escape = "0.2"
regex = "1.10"
zeroize = { version = "1.7", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
reqwest = { version = "0.11", features = ["json", "rustls-tls"], default-features = false }

# å¼€å‘ä¾èµ–
[dev-dependencies]
cargo-audit = "0.20"

# å®‰å…¨é…ç½®
[profile.release]
# å¯ç”¨æ‰€æœ‰å®‰å…¨ä¼˜åŒ–
panic = "abort"
codegen-units = 1
lto = true
strip = true
```

## ä¾‹å¤–æƒ…å†µ
- å¼€å‘ç¯å¢ƒå¯ä»¥ä½¿ç”¨ HTTP (localhost)
- æ¼”ç¤ºä»£ç å¯ä»¥åŒ…å«æ¨¡æ‹Ÿçš„æ•æ„Ÿæ•°æ®
- æµ‹è¯•ä»£ç å¯ä»¥ä½¿ç”¨ç®€åŒ–çš„å®‰å…¨æ£€æŸ¥
- å‘åå…¼å®¹æ€§è¦æ±‚å¯èƒ½éœ€è¦ä¿ç•™æŸäº›ä¸å®‰å…¨çš„ API
