---
description: Dioxus 0.6.3 组件开发规范和最佳实践
globs:
  - 'src/components/**/*.rs'
  - 'examples/components/**/*.rs'
alwaysApply: true
priority: high
---

# Dioxus 组件开发规范

## 目标
确保所有 Dioxus 组件遵循框架最佳实践，提供一致的开发体验和高性能的用户界面。

## 上下文
- 基于 Dioxus 0.6.3 框架
- 适配 Ant Design 设计系统
- 支持 WebAssembly 目标优化
- 兼容服务端渲染 (SSR)

## 规则

### 组件定义
- 使用 `#[component]` 宏定义组件
- Props 结构体必须实现 `Props`、`Clone`、`PartialEq`
- 组件函数返回 `Element` 类型

✅ **正确示例**:
```rust
use dioxus::prelude::*;

#[derive(Props, Clone, PartialEq)]
pub struct ButtonProps {
    #[props(default)]
    pub button_type: ButtonType,

    #[props(default = false)]
    pub disabled: bool,

    #[props(default)]
    pub onclick: Option<EventHandler<MouseEvent>>,

    children: Element,
}

#[component]
pub fn Button(props: ButtonProps) -> Element {
    rsx! {
        button {
            class: "ant-btn",
            disabled: props.disabled,
            onclick: move |evt| {
                if let Some(handler) = &props.onclick {
                    handler.call(evt);
                }
            },
            {props.children}
        }
    }
}
```

### Props 设计原则
- 使用 `#[props(default)]` 为可选属性提供默认值
- 布尔属性默认为 `false`
- 事件处理器使用 `Option<EventHandler<T>>`
- 子元素使用 `children: Element`

✅ **Props 最佳实践**:
```rust
#[derive(Props, Clone, PartialEq)]
pub struct InputProps {
    // 必需属性
    pub value: String,

    // 可选属性，带默认值
    #[props(default)]
    pub placeholder: Option<String>,

    #[props(default = InputSize::Middle)]
    pub size: InputSize,

    #[props(default = false)]
    pub disabled: bool,

    // 事件处理器
    #[props(default)]
    pub onchange: Option<EventHandler<String>>,

    #[props(default)]
    pub onblur: Option<EventHandler<FocusEvent>>,

    // 样式相关
    #[props(default)]
    pub class: Option<String>,

    #[props(default)]
    pub style: Option<String>,
}
```

### RSX 语法规范
- 使用 `rsx!` 宏构建 UI
- 属性使用 snake_case 命名
- 条件渲染使用 `if` 表达式
- 列表渲染使用迭代器

✅ **RSX 最佳实践**:
```rust
#[component]
pub fn List(props: ListProps) -> Element {
    rsx! {
        div {
            class: "ant-list",

            // 条件渲染
            if props.header.is_some() {
                div {
                    class: "ant-list-header",
                    {props.header.unwrap()}
                }
            }

            // 列表渲染
            div {
                class: "ant-list-items",
                for item in props.items.iter() {
                    div {
                        key: "{item.id}",
                        class: "ant-list-item",
                        {item.content.clone()}
                    }
                }
            }
        }
    }
}
```

### 状态管理
- 使用 `use_signal` 管理组件状态
- 使用 `use_memo` 缓存计算结果
- 使用 `use_effect` 处理副作用
- 使用 `use_context` 共享全局状态

✅ **状态管理示例**:
```rust
#[component]
pub fn Counter() -> Element {
    let mut count = use_signal(|| 0);

    // 计算属性
    let is_even = use_memo(move || count() % 2 == 0);

    // 副作用
    use_effect(move || {
        log::info!("Count changed to: {}", count());
    });

    rsx! {
        div {
            class: "counter",
            p { "Count: {count}" }
            p { "Is even: {is_even}" }
            button {
                onclick: move |_| count += 1,
                "Increment"
            }
        }
    }
}
```

### 事件处理
- 事件处理器使用 `move` 闭包
- 避免在事件处理器中进行重计算
- 使用 `prevent_default()` 阻止默认行为

✅ **事件处理示例**:
```rust
#[component]
pub fn Form(props: FormProps) -> Element {
    let mut form_data = use_signal(|| FormData::default());

    let handle_submit = move |evt: FormEvent| {
        evt.prevent_default();

        if let Some(onsubmit) = &props.onsubmit {
            onsubmit.call(form_data());
        }
    };

    rsx! {
        form {
            onsubmit: handle_submit,
            // 表单内容
        }
    }
}
```

### 样式集成
- 使用 CSS-in-Rust 生成样式
- 支持主题变量
- 确保样式的作用域隔离

✅ **样式集成示例**:
```rust
use crate::theme::use_theme;
use css_in_rust::*;

#[component]
pub fn StyledButton(props: ButtonProps) -> Element {
    let theme = use_theme();

    let button_style = css! {
        background_color: theme.primary_color,
        color: theme.primary_text_color,
        border: "none",
        border_radius: theme.border_radius,
        padding: "8px 16px",
        cursor: "pointer",

        "&:hover" {
            background_color: theme.primary_color_hover,
        },

        "&:disabled" {
            background_color: theme.disabled_color,
            cursor: "not-allowed",
        }
    };

    rsx! {
        button {
            class: "{button_style}",
            disabled: props.disabled,
            {props.children}
        }
    }
}
```

### 性能优化
- 使用 `memo` 包装纯组件
- 避免在渲染函数中创建新对象
- 合理使用 `key` 属性优化列表渲染

✅ **性能优化示例**:
```rust
// 使用 memo 优化纯组件
#[component]
pub fn ExpensiveComponent(props: ExpensiveProps) -> Element {
    memo(rsx! {
        div {
            class: "expensive-component",
            // 复杂的渲染逻辑
        }
    })
}

// 列表渲染优化
#[component]
pub fn OptimizedList(props: ListProps) -> Element {
    rsx! {
        div {
            for (index, item) in props.items.iter().enumerate() {
                div {
                    key: "{item.id}", // 使用稳定的 key
                    class: "list-item",
                    {item.render()}
                }
            }
        }
    }
}
```

### 错误边界
- 使用 `ErrorBoundary` 组件处理错误
- 提供友好的错误提示
- 记录错误信息用于调试

✅ **错误处理示例**:
```rust
#[component]
pub fn SafeComponent(props: ComponentProps) -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: |error| {
                log::error!("Component error: {:?}", error);
                rsx! {
                    div {
                        class: "error-fallback",
                        "Something went wrong. Please try again."
                    }
                }
            },

            // 可能出错的组件
            RiskyComponent { props }
        }
    }
}
```

## 例外情况
- 性能关键组件可以使用更底层的 API
- 与第三方库集成时可能需要特殊处理
- 实验性功能可以暂时不遵循某些规范
