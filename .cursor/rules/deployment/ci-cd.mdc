---
description: æŒç»­é›†æˆå’ŒæŒç»­éƒ¨ç½²è§„èŒƒï¼Œç¡®ä¿ä»£ç è´¨é‡å’Œè‡ªåŠ¨åŒ–å‘å¸ƒæµç¨‹
globs:
  - '.github/**/*'
  - 'scripts/**/*'
  - 'Cargo.toml'
  - 'package.json'
alwaysApply: true
priority: medium
---

# CI/CD è§„èŒƒ

## ç›®æ ‡
å»ºç«‹å®Œæ•´çš„æŒç»­é›†æˆå’ŒæŒç»­éƒ¨ç½²æµç¨‹ï¼Œç¡®ä¿ä»£ç è´¨é‡ã€è‡ªåŠ¨åŒ–æµ‹è¯•å’Œå¯é çš„å‘å¸ƒç®¡ç†ã€‚

## ä¸Šä¸‹æ–‡
- åŸºäº GitHub Actions çš„ CI/CD æµç¨‹
- æ”¯æŒå¤šå¹³å°æ„å»º (Web, Desktop, Mobile)
- é›†æˆä»£ç è´¨é‡æ£€æŸ¥å’Œå®‰å…¨æ‰«æ
- è‡ªåŠ¨åŒ–ç‰ˆæœ¬ç®¡ç†å’Œå‘å¸ƒ
- æ”¯æŒå¤šç¯å¢ƒéƒ¨ç½² (å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§)

## è§„åˆ™

### GitHub Actions å·¥ä½œæµé…ç½®
- ä½¿ç”¨æ ‡å‡†åŒ–çš„å·¥ä½œæµæ¨¡æ¿
- å®æ–½å¹¶è¡Œæ„å»ºå’Œæµ‹è¯•
- é›†æˆç¼“å­˜æœºåˆ¶æé«˜æ•ˆç‡
- é…ç½®é€‚å½“çš„è§¦å‘æ¡ä»¶

âœ… **ä¸»è¦ CI å·¥ä½œæµ**:
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # æ¯æ—¥æ„å»ºæ£€æŸ¥ä¾èµ–æ›´æ–°
    - cron: '0 2 * * *'

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Run Clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Check documentation
        run: cargo doc --no-deps --document-private-items
        env:
          RUSTDOCFLAGS: "-D warnings"

      - name: Security audit
        run: |
          cargo install cargo-audit
          cargo audit

      - name: License check
        run: |
          cargo install cargo-license
          cargo license --json | jq '.[] | select(.license != "MIT" and .license != "Apache-2.0" and .license != "BSD-3-Clause")' | jq -s 'if length > 0 then error("Incompatible licenses found") else empty end'

  # æµ‹è¯•çŸ©é˜µ
  test:
    name: Test Suite
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, beta]
        exclude:
          # å‡å°‘çŸ©é˜µå¤§å°ï¼Œåªåœ¨ Ubuntu ä¸Šæµ‹è¯• beta
          - os: windows-latest
            rust: beta
          - os: macos-latest
            rust: beta

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ matrix.rust }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Run tests
        run: cargo test --verbose --all-features

      - name: Run doctests
        run: cargo test --doc

      - name: Test examples
        run: |
          for example in examples/*.rs; do
            echo "Testing example: $example"
            cargo check --example $(basename "$example" .rs)
          done

  # WebAssembly æ„å»ºæµ‹è¯•
  wasm:
    name: WebAssembly Build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: wasm-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Build for WebAssembly
        run: |
          wasm-pack build --target web --out-dir pkg
          ls -la pkg/

      - name: Test WebAssembly
        run: wasm-pack test --headless --firefox

      - name: Check bundle size
        run: |
          WASM_SIZE=$(stat -c%s pkg/*.wasm)
          echo "WASM bundle size: $WASM_SIZE bytes"
          # è­¦å‘Šå¦‚æœåŒ…å¤§å°è¶…è¿‡ 1MB
          if [ $WASM_SIZE -gt 1048576 ]; then
            echo "::warning::WASM bundle size ($WASM_SIZE bytes) exceeds 1MB"
          fi

      - name: Upload WASM artifacts
        uses: actions/upload-artifact@v3
        with:
          name: wasm-build-${{ github.sha }}
          path: pkg/
          retention-days: 7

  # ä»£ç è¦†ç›–ç‡
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install tarpaulin
        run: cargo install cargo-tarpaulin

      - name: Generate coverage report
        run: |
          cargo tarpaulin --verbose --all-features --workspace --timeout 120 \
            --exclude-files 'examples/*' 'tests/*' \
            --out xml --output-dir coverage/

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: coverage/cobertura.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  # æ€§èƒ½åŸºå‡†æµ‹è¯•
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Run benchmarks
        run: |
          cargo bench --bench component_benchmarks -- --output-format json | tee benchmark_results.json

      - name: Store benchmark results
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'cargo'
          output-file-path: benchmark_results.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true
          comment-on-alert: true
          alert-threshold: '200%'
          fail-on-alert: true
```

### å‘å¸ƒå·¥ä½œæµ
- è‡ªåŠ¨åŒ–ç‰ˆæœ¬ç®¡ç†
- ç”Ÿæˆå˜æ›´æ—¥å¿—
- åˆ›å»º GitHub Release
- å‘å¸ƒåˆ°åŒ…ç®¡ç†å™¨

âœ… **å‘å¸ƒå·¥ä½œæµ**:
```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'

env:
  CARGO_TERM_COLOR: always

jobs:
  # åˆ›å»º GitHub Release
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          # è·å–ä¸Šä¸€ä¸ªæ ‡ç­¾
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges)
          else
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges $PREVIOUS_TAG..HEAD)
          fi

          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body: |
            ## Changes
            ${{ steps.changelog.outputs.CHANGELOG }}

            ## Installation

            Add this to your `Cargo.toml`:

            ```toml
            [dependencies]
            ant-design-dioxus = "${{ github.ref_name }}"
            ```
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}

  # æ„å»ºå’Œä¸Šä¼ èµ„äº§
  build-assets:
    name: Build Release Assets
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            asset_name: ant-design-dioxus-linux-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            asset_name: ant-design-dioxus-windows-x86_64
          - os: macos-latest
            target: x86_64-apple-darwin
            asset_name: ant-design-dioxus-macos-x86_64
          - os: macos-latest
            target: aarch64-apple-darwin
            asset_name: ant-design-dioxus-macos-aarch64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Build release binary
        run: |
          cargo build --release --target ${{ matrix.target }}

      - name: Create asset archive
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            7z a ${{ matrix.asset_name }}.zip target/${{ matrix.target }}/release/*.exe
          else
            tar -czf ${{ matrix.asset_name }}.tar.gz -C target/${{ matrix.target }}/release .
          fi

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ matrix.asset_name }}.*
          asset_name: ${{ matrix.asset_name }}.*
          asset_content_type: application/octet-stream

  # å‘å¸ƒåˆ° crates.io
  publish-crate:
    name: Publish to crates.io
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Publish to crates.io
        run: |
          cargo publish --token ${{ secrets.CRATES_IO_TOKEN }}
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}

  # æ„å»ºå’Œéƒ¨ç½²æ–‡æ¡£
  deploy-docs:
    name: Deploy Documentation
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build documentation
        run: |
          cargo doc --no-deps --all-features
          echo '<meta http-equiv="refresh" content="0; url=ant_design_dioxus">' > target/doc/index.html

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc
          cname: ant-design-dioxus.github.io
```

### ä»£ç è´¨é‡é—¨ç¦
- å¼ºåˆ¶ä»£ç æ ¼å¼åŒ–
- Clippy è­¦å‘Šæ£€æŸ¥
- æµ‹è¯•è¦†ç›–ç‡è¦æ±‚
- å®‰å…¨æ¼æ´æ‰«æ

âœ… **è´¨é‡æ£€æŸ¥è„šæœ¬**:
```bash
#!/bin/bash
# scripts/quality-check.sh

set -e

echo "ğŸ” Running code quality checks..."

# 1. æ ¼å¼åŒ–æ£€æŸ¥
echo "ğŸ“ Checking code formatting..."
if ! cargo fmt --all -- --check; then
    echo "âŒ Code formatting check failed. Run 'cargo fmt' to fix."
    exit 1
fi
echo "âœ… Code formatting is correct."

# 2. Clippy æ£€æŸ¥
echo "ğŸ”§ Running Clippy..."
if ! cargo clippy --all-targets --all-features -- -D warnings; then
    echo "âŒ Clippy found issues. Please fix them."
    exit 1
fi
echo "âœ… Clippy checks passed."

# 3. æµ‹è¯•
echo "ğŸ§ª Running tests..."
if ! cargo test --all-features; then
    echo "âŒ Tests failed."
    exit 1
fi
echo "âœ… All tests passed."

# 4. æ–‡æ¡£æµ‹è¯•
echo "ğŸ“š Running documentation tests..."
if ! cargo test --doc; then
    echo "âŒ Documentation tests failed."
    exit 1
fi
echo "âœ… Documentation tests passed."

# 5. ç¤ºä¾‹æ£€æŸ¥
echo "ğŸ’¡ Checking examples..."
for example in examples/*.rs; do
    if [ -f "$example" ]; then
        example_name=$(basename "$example" .rs)
        echo "  Checking example: $example_name"
        if ! cargo check --example "$example_name"; then
            echo "âŒ Example $example_name failed to compile."
            exit 1
        fi
    fi
done
echo "âœ… All examples compile successfully."

# 6. å®‰å…¨å®¡è®¡
echo "ğŸ”’ Running security audit..."
if ! cargo audit; then
    echo "âŒ Security vulnerabilities found."
    exit 1
fi
echo "âœ… No security vulnerabilities found."

# 7. ä¾èµ–æ£€æŸ¥
echo "ğŸ“¦ Checking dependencies..."
if ! cargo tree --duplicates; then
    echo "âš ï¸  Duplicate dependencies found."
fi

# 8. åŒ…å¤§å°æ£€æŸ¥
echo "ğŸ“ Checking package size..."
cargo package --list | wc -l
echo "Package contains $(cargo package --list | wc -l) files"

# 9. WASM æ„å»ºæ£€æŸ¥
if command -v wasm-pack &> /dev/null; then
    echo "ğŸŒ Checking WebAssembly build..."
    if ! wasm-pack build --target web --dev; then
        echo "âŒ WebAssembly build failed."
        exit 1
    fi
    echo "âœ… WebAssembly build successful."
else
    echo "âš ï¸  wasm-pack not found, skipping WASM build check."
fi

echo "ğŸ‰ All quality checks passed!"
```

### éƒ¨ç½²è„šæœ¬
- ç¯å¢ƒé…ç½®ç®¡ç†
- è‡ªåŠ¨åŒ–éƒ¨ç½²æµç¨‹
- å›æ»šæœºåˆ¶
- å¥åº·æ£€æŸ¥

âœ… **éƒ¨ç½²è„šæœ¬ç¤ºä¾‹**:
```bash
#!/bin/bash
# scripts/deploy.sh

set -e

# é…ç½®
ENVIRONMENT=${1:-staging}
VERSION=${2:-latest}
DEPLOY_DIR="/var/www/ant-design-dioxus"
BACKUP_DIR="/var/backups/ant-design-dioxus"

echo "ğŸš€ Deploying ant-design-dioxus to $ENVIRONMENT environment..."
echo "ğŸ“¦ Version: $VERSION"

# 1. é¢„æ£€æŸ¥
echo "ğŸ” Running pre-deployment checks..."
if [ ! -d "$DEPLOY_DIR" ]; then
    echo "âŒ Deploy directory $DEPLOY_DIR does not exist."
    exit 1
fi

# 2. å¤‡ä»½å½“å‰ç‰ˆæœ¬
echo "ğŸ’¾ Creating backup..."
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_PATH="$BACKUP_DIR/backup_$TIMESTAMP"
mkdir -p "$BACKUP_PATH"
cp -r "$DEPLOY_DIR"/* "$BACKUP_PATH/" 2>/dev/null || true
echo "âœ… Backup created at $BACKUP_PATH"

# 3. æ„å»ºæ–°ç‰ˆæœ¬
echo "ğŸ”¨ Building for $ENVIRONMENT..."
case $ENVIRONMENT in
    "production")
        cargo build --release
        wasm-pack build --target web --release
        ;;
    "staging")
        cargo build --release
        wasm-pack build --target web --dev
        ;;
    "development")
        cargo build
        wasm-pack build --target web --dev
        ;;
    *)
        echo "âŒ Unknown environment: $ENVIRONMENT"
        exit 1
        ;;
esac

# 4. è¿è¡Œæµ‹è¯•
echo "ğŸ§ª Running deployment tests..."
cargo test --release

# 5. éƒ¨ç½²æ–‡ä»¶
echo "ğŸ“‚ Deploying files..."
cp -r pkg/* "$DEPLOY_DIR/"
cp -r examples/* "$DEPLOY_DIR/examples/" 2>/dev/null || true

# 6. æ›´æ–°é…ç½®
echo "âš™ï¸  Updating configuration..."
cat > "$DEPLOY_DIR/config.json" << EOF
{
  "environment": "$ENVIRONMENT",
  "version": "$VERSION",
  "deployed_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "build_info": {
    "rust_version": "$(rustc --version)",
    "commit_hash": "$(git rev-parse HEAD 2>/dev/null || echo 'unknown')"
  }
}
EOF

# 7. å¥åº·æ£€æŸ¥
echo "ğŸ¥ Running health checks..."
sleep 5  # ç­‰å¾…æœåŠ¡å¯åŠ¨

# æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if [ ! -f "$DEPLOY_DIR/ant_design_dioxus.js" ]; then
    echo "âŒ Main JavaScript file not found after deployment."
    echo "ğŸ”„ Rolling back..."
    cp -r "$BACKUP_PATH"/* "$DEPLOY_DIR/"
    exit 1
fi

# æ£€æŸ¥ WASM æ–‡ä»¶
if [ ! -f "$DEPLOY_DIR/ant_design_dioxus_bg.wasm" ]; then
    echo "âŒ WASM file not found after deployment."
    echo "ğŸ”„ Rolling back..."
    cp -r "$BACKUP_PATH"/* "$DEPLOY_DIR/"
    exit 1
fi

# 8. æ¸…ç†æ—§å¤‡ä»½ï¼ˆä¿ç•™æœ€è¿‘ 5 ä¸ªï¼‰
echo "ğŸ§¹ Cleaning up old backups..."
ls -t "$BACKUP_DIR" | tail -n +6 | xargs -I {} rm -rf "$BACKUP_DIR/{}"

echo "ğŸ‰ Deployment completed successfully!"
echo "ğŸ“Š Deployment summary:"
echo "  Environment: $ENVIRONMENT"
echo "  Version: $VERSION"
echo "  Deployed at: $(date)"
echo "  Backup location: $BACKUP_PATH"

# 9. å‘é€é€šçŸ¥ï¼ˆå¯é€‰ï¼‰
if [ -n "$SLACK_WEBHOOK_URL" ]; then
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"ğŸš€ ant-design-dioxus deployed to $ENVIRONMENT (version: $VERSION)\"}" \
        "$SLACK_WEBHOOK_URL"
fi
```

### ç¯å¢ƒé…ç½®ç®¡ç†
- å¤šç¯å¢ƒé…ç½®
- å¯†é’¥ç®¡ç†
- ç¯å¢ƒå˜é‡é…ç½®
- é…ç½®éªŒè¯

âœ… **ç¯å¢ƒé…ç½®ç¤ºä¾‹**:
```toml
# config/development.toml
[environment]
name = "development"
debug = true
log_level = "debug"

[build]
optimization = false
source_maps = true
minify = false

[features]
experimental = true
debug_tools = true
performance_monitoring = false

[cdn]
base_url = "http://localhost:8080"
use_cdn = false

[analytics]
enabled = false
```

```toml
# config/production.toml
[environment]
name = "production"
debug = false
log_level = "warn"

[build]
optimization = true
source_maps = false
minify = true

[features]
experimental = false
debug_tools = false
performance_monitoring = true

[cdn]
base_url = "https://cdn.ant-design-dioxus.com"
use_cdn = true

[analytics]
enabled = true
tracking_id = "${ANALYTICS_TRACKING_ID}"
```

```rust
// src/config/mod.rs
use serde::{Deserialize, Serialize};
use std::env;

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Config {
    pub environment: EnvironmentConfig,
    pub build: BuildConfig,
    pub features: FeatureConfig,
    pub cdn: CdnConfig,
    pub analytics: AnalyticsConfig,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct EnvironmentConfig {
    pub name: String,
    pub debug: bool,
    pub log_level: String,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct BuildConfig {
    pub optimization: bool,
    pub source_maps: bool,
    pub minify: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct FeatureConfig {
    pub experimental: bool,
    pub debug_tools: bool,
    pub performance_monitoring: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CdnConfig {
    pub base_url: String,
    pub use_cdn: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AnalyticsConfig {
    pub enabled: bool,
    pub tracking_id: Option<String>,
}

impl Config {
    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        let env = env::var("ENVIRONMENT").unwrap_or_else(|_| "development".to_string());
        let config_path = format!("config/{}.toml", env);

        let config_content = std::fs::read_to_string(&config_path)
            .map_err(|e| format!("Failed to read config file {}: {}", config_path, e))?;

        // æ›¿æ¢ç¯å¢ƒå˜é‡
        let config_content = expand_env_vars(&config_content);

        let config: Config = toml::from_str(&config_content)
            .map_err(|e| format!("Failed to parse config: {}", e))?;

        // éªŒè¯é…ç½®
        config.validate()?;

        Ok(config)
    }

    fn validate(&self) -> Result<(), Box<dyn std::error::Error>> {
        // éªŒè¯æ—¥å¿—çº§åˆ«
        match self.environment.log_level.as_str() {
            "trace" | "debug" | "info" | "warn" | "error" => {},
            _ => return Err(format!("Invalid log level: {}", self.environment.log_level).into()),
        }

        // éªŒè¯ CDN URL
        if self.cdn.use_cdn && !self.cdn.base_url.starts_with("https://") {
            return Err("CDN base URL must use HTTPS in production".into());
        }

        // éªŒè¯åˆ†æé…ç½®
        if self.analytics.enabled && self.analytics.tracking_id.is_none() {
            return Err("Analytics tracking ID is required when analytics is enabled".into());
        }

        Ok(())
    }
}

fn expand_env_vars(content: &str) -> String {
    let mut result = content.to_string();

    // ç®€å•çš„ç¯å¢ƒå˜é‡æ›¿æ¢
    for (key, value) in env::vars() {
        let placeholder = format!("${{{}}}", key);
        result = result.replace(&placeholder, &value);
    }

    result
}
```

## ä¾‹å¤–æƒ…å†µ
- çƒ­ä¿®å¤å¯ä»¥è·³è¿‡æŸäº›æ£€æŸ¥æµç¨‹
- å®éªŒæ€§åŠŸèƒ½å¯ä»¥ä½¿ç”¨ç®€åŒ–çš„ CI æµç¨‹
- å¼€å‘åˆ†æ”¯å¯ä»¥æœ‰è¾ƒå®½æ¾çš„è´¨é‡è¦æ±‚
- ç´§æ€¥å‘å¸ƒå¯ä»¥ä½¿ç”¨å¿«é€Ÿé€šé“
